import sys
import time

import dolfin

try:
    from dolfin_adjoint import as_backend_type, assemble
except ImportError:
    from dolfin import assemble, as_backend_type

from .utils import enlist, getLogger, mpi_comm_world

logger = getLogger(__name__)


class NonlinearProblem(dolfin.NonlinearProblem):
    def __init__(
        self, J, F, bcs, output_matrix=False, output_matrix_path="output", **kwargs
    ):
        super().__init__(**kwargs)
        self.bilinear_form = J
        self.linear_form = F

        self.bcs = enlist(bcs)
        self.output_matrix = output_matrix
        self.output_matrix_path = output_matrix_path
        self.verbose = True
        self.n = 0

    def F(self, b, x):
        assemble(self.linear_form, tensor=b)
        for bc in self.bcs:
            bc.apply(b, x)

    def J(self, A, x):
        assemble(self.bilinear_form, tensor=A)
        for bc in self.bcs:
            bc.apply(A)

        if self.output_matrix:
            filename = "{}/J_{:04d}.mtx".format(self.output_matrix_path, self.n)
            with open(filename, "w") as f:
                mat = as_backend_type(A).mat()
                (num_rows, num_columns) = mat.size
                (ai, aj, av) = mat.getValuesCSR()
                num_nonzeros = len(av)
                f.write("%%MatrixMarket matrix coordinate real general\n")
                f.write("% Generated by {}\n".format(" ".join(sys.argv)))
                f.write("{} {} {}\n".format(num_rows, num_columns, num_nonzeros))
                for i in range(num_rows):
                    for k in range(ai[i], ai[i + 1]):
                        f.write("{} {} {}\n".format(i + 1, aj[k] + 1, av[k]))

            if self.verbose:
                print("Assembled matrix written to {}".format(filename))
            self.n = self.n + 1


class NonlinearSolver:
    def __init__(
        self, problem: NonlinearProblem, state, parameters=None, verbose=False
    ):

        self._handle_parameters(parameters, verbose)
        self._problem = problem
        self._state = state

        self._solver = dolfin.PETScSNESSolver(mpi_comm_world())
        self._solver.parameters.update(self.parameters)
        self._snes = self._solver.snes()
        self._snes.setConvergenceHistory()

        logger.info(f"Linear Solver : {self._solver.parameters['linear_solver']}")
        logger.info(f"Preconditioner:  {self._solver.parameters['preconditioner']}")
        logger.info(f"atol: {self._solver.parameters['absolute_tolerance']}")
        logger.info(f"rtol: {self._solver.parameters['relative_tolerance']}")
        logger.info(f" Size          : {self._state.function_space().dim()}")

    def _handle_parameters(self, parameters, verbose):
        ps = NonlinearSolver.default_solver_parameters()
        if parameters is not None:
            ps.update(parameters)
        petsc = ps.pop("petsc")
        for k, v in petsc.items():
            if v is not None:
                dolfin.PETScOptions.set(k, v)
        if verbose:
            dolfin.PETScOptions.set("ksp_monitor")
            dolfin.PETScOptions.set("log_view")
            dolfin.PETScOptions.set("ksp_view")
            dolfin.PETScOptions.set("pc_view")
            dolfin.PETScOptions.set("mat_superlu_dist_statprint", True)
            ps["lu_solver"]["report"] = True
            ps["lu_solver"]["vebose"] = True
            ps["report"] = True
            ps["krylov_solver"]["monitor_convergence"] = True
        self.parameters = ps

    @staticmethod
    def default_solver_parameters():
        return {
            "petsc": {
                "ksp_type": "preonly",
                "ksp_rtol": None,
                "ksp_atol": None,
                "ksp_max_it": None,
                "ksp_norm_type": "preconditioned",
                "ksp_gmres_restart": None,
                "pc_type": None,
                "pc_factor_mat_solver_type": None,
                "mat_superlu_dist_equil": True,
                "mat_superlu_dist_rowperm": "LargeDiag_MC64",
                "mat_superlu_dist_colperm": "PARMETIS",
                "mat_superlu_dist_parsymbfact": True,
                "mat_superlu_dist_replacetinypivot": True,
                "mat_superlu_dist_fact": "DOFACT",
                "mat_superlu_dist_iterrefine": True,
                "pc_hypre_type": None,
            },
            "linear_solver": "superlu_dist",
            "preconditioner": "lu",
            "error_on_nonconvergence": False,
            "relative_tolerance": 1e-5,
            "absolute_tolerance": 1e-5,
            "maximum_iterations": 20,
            "report": False,
            "krylov_solver": {
                "absolute_tolerance": 1e-13,
                "relative_tolerance": 1e-13,
                "maximum_iterations": 1000,
                "monitor_convergence": False,
            },
            "lu_solver": {"report": False, "symmetric": False, "verbose": False},
        }

    def solve(self):
        """Solve the problem.

        Returns
        -------
        residual : _solver.snes (???)
            A measure of the accuracy (convergence and error)
            of the performed computation.
        """

        logger.info(" Solving NonLinearProblem ...")

        start = time.time()
        self._solver.solve(self._problem, self._state.vector())
        end = time.time()

        logger.info(f" ... Done in [{end - start:.3f} s")

        residuals = self._snes.getConvergenceHistory()[0]
        num_iterations = self._snes.getLinearSolveIterations()
        logger.info(f"Iterations    : {num_iterations}")
        if num_iterations > 0:
            logger.info(f"Resiudal      : {residuals[-1]}")

        return num_iterations, self._snes.converged
